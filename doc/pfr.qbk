[library Boost.PFR
    [quickbook 1.6]
    [version 2.0]
    [copyright 2016-2020 Antony Polukhin]
    [category Language Features Emulation]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[section Motivation and Intro]

Boost.PFR is a library for very basic reflection that gives you access to structure elements by index and provides other `std::tuple` like methods for user defined types without any macro or boilerplate code.

[section Why tuples are bad and aggregates are more preferable?]

`std::tuple` and `std::pair` are great for generic programming, however they have disadvantages. First of all, code that uses them becomes barely readable. Consider two definitions:

[table:tuples_vs_aggregates
[[ Tuple ] [ Aggregate ]]
[[
```
using auth_info_tuple = std::tuple<
    std::int64_t,
    std::int64_t,
    std::int64_t,
    std::time_t
>;
```
][
```
struct auth_info_aggregate {
    std::int64_t id;
    std::int64_t session_id;
    std::int64_t source_id;
    std::time_t  valid_till;
};
```
]]

Definition via [@https://en.cppreference.com/w/cpp/language/aggregate_initialization aggregate initializable] structure is much more clear. Same story with usages: `return std::get<1>(value);` vs. `return value.session_id;`.

Another advantage of aggregates is a more efficient copy, move construction and assignments.

Because of the above issues many guidelines recommend to [*use aggregates instead of tuples]. However aggregates fail when it comes to the functional like programming.

PFR library [*provides tuple like methods for aggregate initializable structures], making aggregates usable in contexts where only tuples were useful.

[note All you have to do is to add `#include <boost/pfr.hpp>`.

No macro or other type/member registrations required.]

[endsect]


[section Sample with DB]

Imagine that you are writing the wrapper library for database. User of your library wish to implement `retrieve_friend` function:

```
#include <db/api.hpp> // your library

// User code:

struct user_info {
    std::int64_t id;
    std::string name;
    std::int64_t github_stars;
    std::string email;
};

// ...

user_info retrieve_friend(std::string_view name);
```

Depending on the usage of PFR in your DB wrapper users code will look differently:

[table:quick_examples
[[ Without PFR ] [ With PFR ]]
[[
```
user_info retrieve_friend(std::string_view name) {
    std::tuple<<std::int64_t, std::string, std::int64_t>> info
      = db::one_row_as<std::int64_t, std::string, std::int64_t>(
        "SELECT id, name, github_stars, email FROM user_infos WHERE name=$0",
        name
    );

    auto friend_info = ask_user_for_friend(
        user_info{
            std::move(std::get<0>(info)),
            std::move(std::get<1>(info)),
            std::move(std::get<2>(info)),
            std::move(std::get<3>(info)),
        }
    );

    db::insert(
        "INSERT INTO user_infos(id, name, github_stars, email) VALUES ($0, $1, $2, $3)",
        std::move(std::get<0>(friend_info)),
        std::move(std::get<1>(friend_info)),
        std::move(std::get<2>(friend_info)).
        std::move(std::get<3>(friend_info))
    );

    return friend_info;
}

```
][
```
user_info retrieve_friend(std::string_view name) {
    user_info info = db::one_row_as<user_info>(
        "SELECT id, name, github_stars, email FROM user_infos WHERE name=$0",
        name
    );

    auto friend_info = ask_user_for_friend(std::move(info));

    db::insert(
        "INSERT INTO user_infos(id, name, github_stars, email) VALUES ($0, $1, $2, $3)",
        friend_info
    );

    return friend_info;
}
```
]]
]

With PFR the code is shorter, more readable and more pleasant to write.

[endsect]


[section Out of the box functionality ]

Boost.PFR adds the following out-of-the-box functionality for aggregate initializable structures:

* comparison operators
* heterogeneous comparators
* hash
* stream operators
* access to members by index
* member type retrieval
* methods for cooperation with `std::tuple`
* methods to visit each field of the structure

PFR is a header only library that does not depend on Boost. You can just copy the content of the "include" folder [@https://github.com/apolukhin/magic_get from the github] into your project, and the library will work fine.

[endsect]

[warning This is not an official Boost library! It wasn't reviewed and can't be downloaded from www.boost.org. This library is available to the community to know real interest and get comments for refinement. The intention is to submit library to formal review, if community think that it is interesting!]

[caution Recommended C++ Standards are C++17 and above]

[caution Library requires at least C++14! Pre C++14 compilers (C++11, C++03...) are not supported]



[endsect]


[section Short Examples for the Impatient]

Examples in the table use the following definition:

[import ../example/quick_examples.cpp]

[pfr_quick_examples_structures]


[table:quick_examples
[[ Code snippet ] [ `var` content or output ] [ Function description: ]]
[
    [ [pfr_quick_examples_get_1] ]
    [ `var == {A {1, 2.0}}` ]
    [ [funcref boost::pfr::get get] ]
][
    [ [pfr_quick_examples_get_2] ]
    [ `var == {A, {777, 42.01}}` ]
    [ [funcref boost::pfr::get get] ]
][
    [ [pfr_quick_examples_ops] ]
    [ assert succeeds ]
    [ [headerref boost/pfr/ops.hpp using\u00A0namespace\u00A0ops;] ]
][
    [ [pfr_quick_examples_for_each] ]
    [ `var == {B, {787, 103.142}}` ]
    [ [funcref boost::pfr::for_each_field for_each_field] ]
][
    [ [pfr_quick_examples_for_each_idx] ]
    [ ```0: char
1: quick_examples_ns::foo
``` ]
    [ [funcref boost::pfr::for_each_field for_each_field] ]
][
    [ [pfr_quick_examples_tuple_size] ]
    [ `tuple_size: 2` ]
    [ [classref boost::pfr::tuple_size tuple_size] ]
][
    [ [pfr_quick_examples_structure_to_tuple] ]
    [ `var == {A, {777, 3.14159}}` ]
    [ [funcref boost::pfr::structure_to_tuple structure_to_tuple] ]
][
    [ [pfr_quick_examples_structure_tie] ]
    [ `var == {A, {1, 2.0}}` ]
    [ [funcref boost::pfr::structure_tie structure_tie] ]
]]


[endsect]


[section Tutorial]

[import ../example/examples.cpp]

[section Accessing structure member by index] [pfr_example_get] [endsect]
[section Custom printing of aggregates] [pfr_sample_printing] [endsect]
[/ [section Counting fields] [pfr_example_tuple_size] [endsect] ]


[section three ways of getting operators ]

There are three ways to start using Boost.PFR hashing, comparison and streaming for type `T` in your code. Each method has its own drawbacks and suits own cases.

[table:ops_comp Different approaches for operators
    [[ Approach
    ][ Defines operators in global namespace ][ Defined operators could be found by ADL ][ Works for local types ][ Usable locally, without affecting code from other scopes ][ Ignores implicit conversion operators ][ Respects user defined operators ]]

    [[
        [headerref boost/pfr/ops.hpp using\u00A0namespace\u00A0boost::pfr::ops;]
    ][ no ][ no ][ yes ][ yes ][ no ][ yes ]]

    [[
        [macroref BOOST_PFR_FUNCTIONS_FOR]  
    ][ yes if T is in it ][ yes ][ no ][ no, but could be limited to translation unit ][ yes for T ] [ no (compile time error) ]]
]

More detailed description follows:

[*1. [headerref boost/pfr/ops.hpp `using namespace boost::pfr::ops;`] approach]

This method is good if you're writing generic algorithms and need to use operators from Boost.PFR only if there are no operators defined for the type:

```
#include <boost/pfr/ops.hpp>

template <class T>
struct uniform_comparator_less {
    bool operator()(const T& lhs, const T& rhs) const noexcept {
        using namespace boost::pfr::ops;    // Enables Boost.PFR operators usage in this scope.

        // If T has operator< or conversion operator then it is used.
        return lhs < rhs;
    }
};
```
This method's effects are local to the function. It works even for local types, like structures defined in functions.
However *Argument Dependant Lookup* does not work with it:

```
#include <boost/pfr/ops.hpp>
template <class T>
struct uniform_comparator_less {
    bool operator()(const T& lhs, const T& rhs) const noexcept {
        using namespace ops;

        // Compile time error if T has neither operator< nor
        // conversion operator to comparable type.
        return std::less{}(lhs, rhs);
    }
};
```

[*2. [macroref BOOST_PFR_FUNCTIONS_FOR] approach]

This method is good if you're writing a structure and wish to define operators for that structure.
```
#include <boost/pfr/functions_for.hpp>

struct pair_like {
    int first;
    short second;
};

BOOST_PFR_FUNCTIONS_FOR(pair_like)   // Defines operators

// ...

assert(pair_like{1, 2} < pair_like{1, 3});
```
Argument Dependant Lookup works well. `std::less` will find the operators for `struct pair_like`. [macroref BOOST_PFR_FUNCTIONS_FOR BOOST_PFR_FUNCTIONS_FOR(T)]
can not be used for local types. It must be called only once in namespace of `T`. It does not respect conversion operators of `T`, so for example the following code
will output different values:
```
#include <boost/pfr/functions_for.hpp>

struct empty {
    operator std::string() { return "empty{}"; }
};
// Uncomment to get different output:
// BOOST_PFR_FUNCTIONS_FOR(empty)

// ...
std::cout << empty{}; // Outputs `empty{}` if BOOST_PFR_FUNCTIONS_FOR(empty) is commented out, '{}' otherwise.
```

[endsect]


[section Reflection of unions ]

You could use tuple-like representation if a type contains union. But be sure that operations for union are manually defined:

```
#include <boost/pfr/ops.hpp>

union test_union {
    int i;
    float f;
};

inline bool operator==(test_union l, test_union r) noexcept; // Compile time error without this operator


struct foo { int i; test_union u; };

bool some_function(foo f1, foo f2) {
    using namespace boost::pfr::ops;
    return f1 == f2; // OK
}

```

Reflection of unions is disabled for safety reasons. There's a way to get the first member of a union and use it. Unfortunately there's no way to find out [*active] member of a union. Accessing an inactive union member is an Undefined Behavior. Using the first union member could lead to disaster if it is some character pointer. For example ostreaming `union {char* c; long long ll; } u; u.ll= 1;` will crash your program, as the active member is `ll` that holds `1` but we are trying to output a `char*`. This would cause an invalid pointer dereference.

Any attempt to reflect unions leads to a compile time error. In many cases a static assert is triggered that outputs the following message:

```
error: static_assert failed "====================> Boost.PFR: For safety reasons it is forbidden
        to reflect unions. See `Reflection of unions` section in the docs for more info."
```

[endsect]

[endsect]

[section Configuration Macro]

By default Boost.PFR [*auto-detects your compiler abilities] and automatically defines the configuration macro into appropriate values. If you wish to override that behavior, just define:
[table:linkmacro Macros
    [[Macro name] [Effect]]
    [[*BOOST_PFR_USE_CPP17*] [Define to `1` if you wish to use structured bindings and other C++17 features for reflection. Define to `0` otherwise.]]
    [[*BOOST_PFR_USE_LOOPHOLE*] [Define to `1` if you wish to exploit [@http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2118 CWG 2118] for reflection. Define to `0` otherwise.]]
    [[*BOOST_PFR_USE_STD_MAKE_INTEGRAL_SEQUENCE*] [Define to `0` if you are hit by the template instantiation depth issues with `std::make_integer_sequence` and wish to use PFR version of that metafunction. Define to `1` otherwize. ]]
]

Library prefers to use structured bindings for reflection if they are available, otherwise falls back to [*Loophole].

Note that disabling [*Loophole] in C++14 significantly limits the reflection abilities of the library. See next section for more info on limitations.


[endsect]


[section Limitations]

The reflection has some limitations that depend on a C++ Standard and compiler capabilities:

* Static variables are ignored
* T must be [@https://en.cppreference.com/w/cpp/language/aggregate_initialization aggregate initializable] without empty base classes
* if T contains C arrays or it is inherited from non-empty type then the result of reflection may differ depending on the C++ version and library configuration
* Additional C++14 [*only] limitations (switch to C++17 to remove all of those):
    * Non of the member fields should have a template constructor from one parameter.
    * Additional limitations if the [link boost_pfr.configuration_macro [*Loophole]] is also disabled:
        * T must be constexpr aggregate initializable and all its fields must be constexpr default constructible
        * [funcref boost::pfr::get], [funcref boost::pfr::structure_to_tuple], [funcref boost::pfr::structure_tie], [headerref boost/pfr/core.hpp boost::pfr::tuple_element] require T to be a flat POD type

[endsect]

[section How it works]

Short description:

# at compile-time: use aggregate initialization to detect fields count in user-provided structure
    * C++17:
        # at compile-time: structured bindings are used to decompose a type `T` to known amount of fields
    * C++14:
        # at compile-time: use aggregate initialization to detect fields count in user-provided structure
        # at compile-time: make a structure that is convertible to anything and remember types it has been converted to during aggregate initialization of user-provided structure
        # at compile-time: using knowledge from previous steps create a tuple with exactly the same layout as in user-provided structure
        # at compile-time: find offsets for each field in user-provided structure using the tuple from previous step
        # at run-time: get pointer to each field, knowing the structure address and each field offset
        # at run-time: a tuple of references to fields is returned => all the tuple methods are available for the structure
    * C++14 with disabled [link boost_pfr.configuration_macro [*Loophole]]:
        # at compile-time: let `I` be is an index of current field, it equals 0
        # at run-time: `T` is constructed and field `I` is aggregate initialized using a separate instance of structure that is convertible to anything [note Additional care is taken to make sure that all the information about `T` is available to the compiler and that operations on `T` have no side effects, so the compiler can optimize away the unnecessary temporary objects.]
        # at compile-time: `I += 1`
        # at compile-time: if `I` does not equal fields count goto step [~c.] from inside of the conversion operator of the structure that is convertible to anything
        # at compile-time: using knowledge from previous steps create a tuple with exactly the same layout as in user-provided structure
        # at compile-time: find offsets for each field in user-provided structure using the tuple from previous step
        # at run-time: get pointer to each field, knowing the structure address and each field offset
# at run-time: a tuple of references to fields is returned => all the tuple methods are available for the structure

Long description of some basics: [@https://youtu.be/UlNUNxLtBI0 Antony Polukhin: Better C++14 reflections].
Long description of some basics of C++14 with disabled [link boost_pfr.configuration_macro [*Loophole]]: [@https://youtu.be/abdeAew3gmQ Antony Polukhin: C++14 Reflections Without Macros, Markup nor External Tooling].

[endsect]

[section Acknowledgements]

Great thanks to Bruno Dutra for showing the technique to precisely reflect aggregate initializable type in C++14 [@https://github.com/apolukhin/magic_get/issues/5 Manual type registering/structured bindings might be unnecessary].

Great thanks to Alexandr Poltavsky for initial implementation the [link boost_pfr.configuration_macro [*Loophole]] technique and for describing it [@http://alexpolt.github.io/type-loophole.html in his blog].

Great thanks to Chris Beck for implementing the detect-offsets-and-get-field-address functionality that avoids Undefined Behavior of reinterpret_casting layout compatible structures.

[endsect]

[section Reference]
[xinclude autodoc_all.xml]
[endsect]
